# 1. x / 3
# 2. x / 2
# 3. x - 1
# 최종 1을 만드는 데 사용하는 연산 횟수의 최소값! -> DP 문제

# dp[i]... 뭐라고 설정해야 하는가... 
    # 1로 만들기 위한 최소 연산 횟수.
# 그걸 어떻게 업데이트 해야 하는가?
    # 1을 빼는 경우
        # dp[i]는 dp[i - 1]
    # 2를 나누는 경우
        # dp[i] = dp[i // 2]
    # 3을 나누는 경우
        # dp[i] = dp[i // 3]



def solution(n):
    dp = [0] * (n + 1)

    # 1은 이미 1이니까 연산 횟수는 0. 
    # 2부터 연산 카운트 의미 있음.
    for i in range(2, n + 1):
        # 1을 빼는 경우
        dp[i] = dp[i-1] + 1
        # 2를 나누는 경우
        if (i % 2) == 0:
            dp[i] = min(dp[i], dp[i//2] + 1)
        # 3을 나누는 경우
        if (1 % 3) == 0:
            dp[i] = min(dp[i], dp[i//3] + 1)

    return dp[n]

n = int(input())
print(solution(n))
