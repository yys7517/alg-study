# 1. 정의

## Dynamic Programming이란?

- **큰 문제를 작은 문제로 나누어 해결하고**, 그 결과를 **저장하여 재사용**하는 알고리즘 기법입니다.
- 동일한 부분 문제가 반복해서 등장할 때, 매번 다시 계산하지 않고 **한 번 계산한 값을 활용**합니다.
- 핵심은 **중복 계산 제거**입니다.

---

# 2. 언제 쓰는가?

## 다음 조건이 보이면 DP를 의심합니다.

- 같은 계산이 여러 번 반복됨
- 문제를 더 작은 문제로 나눌 수 있음
- 작은 문제의 정답이 큰 문제의 정답에 사용됨

## 대표적인 상황

- 최댓값 / 최솟값을 구하는 문제
- 경우의 수를 세는 문제
- 선택/비선택이 반복되는 문제
- 시간 초과가 DFS/브루트포스로 발생하는 문제

---

# 3. 구현 (Python 예시)

## 예시: 피보나치 수열

```python
n = 10
dp = [0] * (n + 1)

dp[1] = 1
dp[2] = 1

for i in range(3, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[n])
```

## 핵심 포인트

- dp[i] : **i번째 문제의 정답**
- 점화식: dp[i] = dp[i-1] + dp[i-2]
- 작은 문제부터 차례대로 계산

---

# **4. 코테에서 자주 터지는 포인트 (중요)**

- DP인지 모르고 완전탐색으로 접근함
- 점화식은 맞는데 **초기값 설정을 잘못함**
- 인덱스 범위 실수 (dp[0], dp[1])
- 메모이제이션 없이 재귀만 사용함
- DP 테이블의 의미를 명확히 정의하지 않음

---

# **5. 실전 꿀팁 (중요)**

- 먼저 **dp 배열이 무엇을 의미하는지 한 문장으로 정의**하세요.
    - 예: dp[i] = i번째까지 고려했을 때의 최대 값
- 점화식은 말로 먼저 써보고 코드로 옮기세요.
- 2차원 DP는 **행/열의 의미**를 명확히 하세요.
- 메모리 제한이 빡빡하면 **1차원으로 줄일 수 있는지** 고민하세요.
- 안 풀리면 **작은 입력 예시를 직접 써서 dp 테이블을 채워보세요.**
