# **1. 정의**

### **정렬(Sort)이란?**

- 여러 개의 값을 **특정 기준에 따라 순서대로 나열**하는 것
- 기준 예시
    - 크기 (오름차순 / 내림차순)
    - 문자열 사전순
    - 특정 속성 (시간, 비용, 점수 등)

> 정렬은 그 자체가 목적이기보다는,
**문제를 풀기 위한 전처리 수단**으로 자주 사용된다.
> 

### **그리디(Greedy)란?**

- 매 순간 **가장 좋아 보이는 선택을 하는 알고리즘**
- 현재 선택이 **미래에 미치는 영향은 고려하지 않음**

> 지금 당장 최선 → 전체에서도 최선이라는
성질이 있을 때만 사용 가능하다.
> 

---

## **2. 언제 쓰는가?**

### **정렬**

- 순서가 섞여 있어 비교가 어려운 경우
- 가장 큰 값 / 작은 값을 반복적으로 선택해야 할 때
- 특정 기준으로 묶거나, 앞뒤 관계가 중요할 때
- 그리디 알고리즘을 적용하기 전

> 👉 **정렬은 단독으로도 쓰이지만, 그리디의 전제 조건인 경우가 많다.**
> 

### **그리디**

- 최소 / 최대
- 가장 빨리 / 가장 많이 / 가장 적게
- 한 번의 선택이 이후 선택에 영향 없음
- 선택을 되돌릴 필요 없음

> 👉 항상 **정렬 + 선택 기준**이 명확해야 한다.
> 

# **3. 구현 (Python 예시)**

## **정렬**

### **기본 정렬**

```python
arr = [5, 2, 9, 1]
arr.sort()              # 오름차순
arr.sort(reverse=True)  # 내림차순
```

### **기준을 가진 정렬**

```python
arr = [(1, 3), (2, 1), (3, 2)]
arr.sort(key=lambda x: x[1])  # 두 번째 값 기준 정렬
```

---

## **그리디**

### **예시: 가장 빨리 끝나는 회의부터 선택**

```python
meetings = [(1, 4), (2, 3), (3, 5)]
meetings.sort(key=lambda x: x[1])  # 종료 시간 기준 정렬

end = 0
count = 0

for start, finish in meetings:
    if start >= end:
        count += 1
        end = finish
```

- 👉 핵심
    - **정렬 기준이 곧 그리디의 핵심**
    - 반복문 안에서는 단순 선택만 한다

---

# **4. 코테에서 자주 터지는 포인트 (중요)**

- ❌ 정렬 기준을 잘못 잡음
- ❌ 그리디로 풀 수 없는 문제를 그리디로 시도
- ❌ “지금 좋아 보이는 선택”이 항상 최적인지 검증 안 함
- ❌ 정렬 없이 그리디 적용

---

# **5. 실전 꿀팁 (중요)**
- 그리디 문제의 70%는 **정렬 기준 싸움**
- 정렬 기준을 바꾸면 문제 난이도가 반으로 줄어든다
- 앞의 선택이 뒤의 선택에 영향을 주어 결과를 뒤집을 수 있는 경우나 반례가 존재하는 경우엔 그리디 사용 금지
- 그리디가 안 되면 다음 알고리즘을 의심할 것
    - DP
    - 완전탐색
    - 이분탐색